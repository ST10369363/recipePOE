## Recipe App — Firebase Edition

This Android application is designed to allow users to easily create, view, edit, and delete recipes. Each recipe is stored under a specific category such as Breakfast, Lunch, Dinner, or Dessert. The app connects to **Firebase Realtime Database** for cloud storage, ensuring that data can be accessed from any device, while also saving a local copy on the user’s phone using **SharedPreferences** for offline access.

When users open the app, they can navigate through three main sections — *Explore*, *Create*, and *Settings*. The **Create** screen allows users to input recipe information such as category, name, ingredients, and preparation steps. Once the “Add” button is pressed, the recipe is uploaded to Firebase and a local copy is saved for offline use. The **My List** screen enables users to view recipes by category. When a category is selected, the recipes that belong to that category are displayed. The user can then select a recipe to view its details. From there, they can choose to edit or delete the recipe. When the recipe is edited, a “Save Changes” button updates the data both in Firebase and in local storage.

The Firebase setup is straightforward. A new Firebase project should be created in the [Firebase Console](https://console.firebase.google.com). Once created, **Realtime Database** should be enabled with the location set to `europe-west1`. For testing purposes, database rules can be set to allow public reads and writes. After creating the database, an Android app with the package name `com.example.recipe` must be added in Firebase. This will generate a `google-services.json` configuration file, which needs to be placed inside the project’s `app` directory.

The Gradle setup is also important. In the project-level `build.gradle` file, the Firebase and Google services plugins should be included. In the app-level `build.gradle` file, the Firebase Database dependency must be added to enable communication between the Android app and the Firebase backend. The Firebase database URL for this project is
`https://recipe-c5ca1-default-rtdb.europe-west1.firebasedatabase.app/`,
and in the code, the Firebase reference should point to the `recipe/create` node as follows:

```kotlin
database = FirebaseDatabase.getInstance(
    "https://recipe-c5ca1-default-rtdb.europe-west1.firebasedatabase.app/"
).getReference("recipe/create")
```

In Firebase, recipes are organized under a parent node named `recipe`, and within it, a subnode called `create` stores each recipe entry. Each recipe entry contains a unique ID generated by Firebase, along with the recipe’s category, name, ingredients, and preparation steps. An example of the Firebase data structure looks like this:

```
recipe
 └─ create
      └─ -OaozXw-agfhcI3S1M-Y
          ├─ category: "Breakfast"
          ├─ name: "Sugar Water"
          ├─ ingredients: ["Water", "Sugar"]
          └─ steps: "Mix water with sugar until dissolved."
```

The **Create screen (`create.kt`)** manages recipe input and saving. It validates user entries and uploads them to Firebase. Once a recipe is successfully added, it displays a confirmation message and saves a backup locally. The **My List screen (`mylist.kt`)** interacts with Firebase to load categories and recipes dynamically. It allows users to select a category, view recipes within it, and make changes. The interface provides buttons for editing, deleting, and saving recipes back to Firebase. A clean, minimal layout makes it easy to navigate, with a simple bottom navigation bar for moving between Explore, Create, and Settings.

Local storage is handled through Android’s SharedPreferences. Each time a recipe is created, a JSON version of the recipe is saved to a local file named `local_recipes`. This ensures that even if the device is offline, a user can still access previously saved data.

To run the project, simply clone it from the repository, open it in Android Studio, add the downloaded `google-services.json` file to the `/app/` directory, and sync the Gradle files. Once the build is complete, the app can be run on an Android device or emulator.

This project serves as a practical example of integrating **Firebase Realtime Database** with **Android Kotlin**, demonstrating CRUD operations (Create, Read, Update, Delete), real-time data synchronization, and simple data caching for offline access. It provides a solid foundation for learning how to manage structured data and user interaction in mobile applications.

Login
 
The login page is the first page the user will see. As you can see, it has a lot going on, but it's still user-friendly. To access the app, the user must be online; if they are not, they won't be able to access it. However, there are safeguards in place in case the user goes offline, so they will need to re-enter their email address and password. They haven't created an account, so how do you sign in with Google or create the real project, which is the app.
Sign in
 
Clicking "create an account" will take the user to the sign-in page where they must enter their name, last name, email address, password, and budget. However, if they click "create an account" or "remember what their information is," they can click "go back," which will return them to the login page.

SSO / Google signin
 
If the user decides not to utilise the app to establish an account, they can click on "create" or "use Google sign-in" or "SSO," which will require the user to have a Google account and make it easier for them to log in.
Settings
 
After successfully logging in, the user will be directed to the settings page, where they can view their email address in case they forget it and select a preferred language. We use the Gemini API key to modify the language features, so as developers, we can choose the language we want to add. Currently, it displays as is, but users can translate languages as they please. After that, the user can choose whether or not to receive notifications and log out of the page.
Navigation 
 
The image displays the navigation; clicking one of the buttons will take the user to the appropriate page. The first icon will direct the user to the explore page, where they can conduct an online recipe search; the middle icon will display the user's recipe book; and the final icon will enable users to create recipes.

Explore page.
   
This image displays the "explore recipes" page. Users will be limited to 15 users per day due to the spoonacular API key we were using. For the time being, users can search for a simple recipe by clicking the search button beneath it. Simple searches will yield a list of recipes that are related to what the user has searched for. If they choose one, the ingredients and instructions will appear on the next page, allowing the user to see the ingredients, steps, and necessary actions. Clicking the back button will return the user to the previous page.
Create a recipe
   
The next page in the image demonstrates how to create a recipe by choosing a recipe category, such as breakfast, lunch, dinner, or dessert music. After that, the user must enter their name, the recipe name, the number of ingredients, and the ingredients in their own cooking steps. They can then select "add to recipe" to receive a notification that their recipe has been added. Additionally, a feature has been added so that if the user was online when accessing the recipe app and for whatever reason, the recipes will be stored on local memory until they return to the cloud database.

My list 
   
The image above depicts my list page, which enables users to view recipes that have been created by first choosing a category, then choosing a recipe within that category. After viewing the recipe details, users can choose whether to edit or delete a recipe.






